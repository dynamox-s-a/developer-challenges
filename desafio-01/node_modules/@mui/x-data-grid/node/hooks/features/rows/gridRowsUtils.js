"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculatePinnedRowsHeight = calculatePinnedRowsHeight;
exports.checkGridRowIdIsValid = checkGridRowIdIsValid;
exports.getTreeNodeDescendants = exports.getRowsStateFromCache = exports.getRowIdFromRowModel = exports.createRowsInternalCache = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _gridRowsSelector = require("./gridRowsSelector");

const _excluded = ["rowsBeforePartialUpdates"];

/**
 * A helper function to check if the id provided is valid.
 * @param {GridRowId} id Id as [[GridRowId]].
 * @param {GridRowModel | Partial<GridRowModel>} row Row as [[GridRowModel]].
 * @param {string} detailErrorMessage A custom error message to display for invalid IDs
 */
function checkGridRowIdIsValid(id, row, detailErrorMessage = 'A row was provided without id in the rows prop:') {
  if (id == null) {
    throw new Error(['MUI: The data grid component requires all rows to have a unique `id` property.', 'Alternatively, you can use the `getRowId` prop to specify a custom id for each row.', detailErrorMessage, JSON.stringify(row)].join('\n'));
  }
}

const getRowIdFromRowModel = (rowModel, getRowId, detailErrorMessage) => {
  const id = getRowId ? getRowId(rowModel) : rowModel.id;
  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);
  return id;
};

exports.getRowIdFromRowModel = getRowIdFromRowModel;

const createRowsInternalCache = ({
  rows,
  getRowId,
  loading,
  rowCount
}) => {
  const cache = {
    rowsBeforePartialUpdates: rows,
    loadingPropBeforePartialUpdates: loading,
    rowCountPropBeforePartialUpdates: rowCount,
    idRowsLookup: {},
    idToIdLookup: {},
    ids: []
  };

  for (let i = 0; i < rows.length; i += 1) {
    const row = rows[i];
    const id = getRowIdFromRowModel(row, getRowId);
    cache.idRowsLookup[id] = row;
    cache.idToIdLookup[id] = id;
    cache.ids.push(id);
  }

  return cache;
};

exports.createRowsInternalCache = createRowsInternalCache;

const getRowsStateFromCache = ({
  apiRef,
  previousTree,
  rowCountProp,
  loadingProp
}) => {
  const _apiRef$current$unsta = apiRef.current.unstable_caches.rows,
        cacheForGrouping = (0, _objectWithoutPropertiesLoose2.default)(_apiRef$current$unsta, _excluded);
  const rowCount = rowCountProp != null ? rowCountProp : 0;
  const groupingResponse = apiRef.current.unstable_applyStrategyProcessor('rowTreeCreation', (0, _extends2.default)({}, cacheForGrouping, {
    previousTree
  }));
  const processedGroupingResponse = apiRef.current.unstable_applyPipeProcessors('hydrateRows', groupingResponse);
  const dataTopLevelRowCount = processedGroupingResponse.treeDepth === 1 ? processedGroupingResponse.ids.length : Object.values(processedGroupingResponse.tree).filter(node => node.parent == null && !node.isPinned).length;
  return (0, _extends2.default)({}, processedGroupingResponse, {
    groupingResponseBeforeRowHydration: groupingResponse,
    loading: loadingProp,
    totalRowCount: Math.max(rowCount, processedGroupingResponse.ids.length),
    totalTopLevelRowCount: Math.max(rowCount, dataTopLevelRowCount)
  });
};

exports.getRowsStateFromCache = getRowsStateFromCache;

const getTreeNodeDescendants = (tree, parentId, skipAutoGeneratedRows) => {
  var _tree$parentId;

  const children = (_tree$parentId = tree[parentId]) == null ? void 0 : _tree$parentId.children;

  if (children == null) {
    return [];
  }

  const validDescendants = [];

  for (let i = 0; i < children.length; i += 1) {
    const child = children[i];
    const childNode = tree[child];

    if (!skipAutoGeneratedRows || !childNode.isAutoGenerated) {
      validDescendants.push(child);
    }

    validDescendants.push(...getTreeNodeDescendants(tree, childNode.id, skipAutoGeneratedRows));
  }

  return validDescendants;
};

exports.getTreeNodeDescendants = getTreeNodeDescendants;

function calculatePinnedRowsHeight(apiRef) {
  var _pinnedRows$top, _pinnedRows$bottom;

  const pinnedRows = (0, _gridRowsSelector.gridPinnedRowsSelector)(apiRef);
  const topPinnedRowsHeight = (pinnedRows == null ? void 0 : (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.reduce((acc, value) => {
    acc += apiRef.current.unstable_getRowHeight(value.id);
    return acc;
  }, 0)) || 0;
  const bottomPinnedRowsHeight = (pinnedRows == null ? void 0 : (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.reduce((acc, value) => {
    acc += apiRef.current.unstable_getRowHeight(value.id);
    return acc;
  }, 0)) || 0;
  return {
    top: topPinnedRowsHeight,
    bottom: bottomPinnedRowsHeight
  };
}